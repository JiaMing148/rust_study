fn main() {
    let mut v:Vec<i32> = vec![1, 2, 3];
    let num: &mut i32 =&mut v[2];
    *num += 1;
    println!("Third element is {}",*num);

    println!("Vector is now {:?}",v);
}

//所有权定义：let a= Box::new(); 
//new的过程 在heap中创建了一个box 同时创建了一个指针指向该内存地址
//特殊的地方在于 a 拿到的是该指针的所有权
//而所有权具有唯一性 当 let b = a; 时 代表 a把该指针的所有权交给了b，意味着a失去了该所有权。
//
//内存回收逻辑: Rust会在所有者变量被释放时，同时释放对应的heap内存
//.clone() 可以克隆数据 在heap中新开辟一个空间

//'&' 可以引用
//fu test(x:&String){}  let a=String::from("Name"); test(&a);  &a就可以在不移交所有权的情况下访问该内存

//'*' 解引用
//作用：可以解除一层引用，直接拿到指向的数据，且可多重解引用。
//let mut x:Box<i32> = Box::new(1);
//let a: i32 =*x;
//多重解引用
//let a = Box:new(1);
//let b = &a;
//let r :i32 = **b; or let r :Box<i32> = *b;
//*x += 1; 现在 a = 1 且类型为i32 而x为 box 2
//Rust 内置函数存在隐式解引用 例如 i32的.abs() string的.len()

//指针安全原则：数据决不能同时使用别名和变异。
//原因：当一个变量a引用了变量b的数据 当变量b更改数据时，由于原数据没用所有者所以被释放，因此变量a就引用了一个无效内存。

//Rust 为了防止出现空引用的情况 设定了以下规则
//R (read 读取)权限 W (write 修改)权限 O (Own 拥有)权限
//当 所有者指针 存在其它的 引用者(&) 时 所有者失去W、O的权限
//只有当 引用者(&) 在后续不再使用时 所有者指针才会重新拥有W、O权限
//该规则 Rust 会在编译阶段检测并报错.

//易错点
//& mut变量时 需要使用可变引用才行 &mut a
//所有变量都可以 W, O, R 其数据
//创建引用会将权限从借用路径转移到引用
//引用生命周期结束，就会归还权限。
//数据必须比所有指向它的引用的生命周期更长。

//总结:引用好比借给他人东西，当东西借出去的时候，你只有那个东西的信息,由于不在手上因此无法更改。
//该过程Rust会在预编译时检验,Rust是AOT(预编译模式)。
//Rust在预编译期间对所有变量的生命周期进行了标记，当一个变量不再使用时就代表它的生命周期结束，自动释放。
//String类型在上下文中必须只存在一个所有者，因为String是堆数据，当存在复数以上的所有者时。Rust最终会释放数次导致错误。

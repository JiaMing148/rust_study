# **ownership 所有权**
所有权定义：let a= Box::new();    
new的过程 在heap中创建了一个box 同时创建了一个指针指向该内存地址  
特殊的地方在于 a 拿到的是该指针的所有权  
而所有权具有唯一性 当 let b = a; 时 代表 a把该指针的所有权交给了b，意味着a失去了该所有权。 

## 内存回收逻辑
内存回收逻辑: Rust会在所有者变量被释放时，同时释放对应的heap内存   
.clone() 可以克隆数据 在heap中新开辟一个空间   

# '&' 可以引用
```Rust
fn test(x:&String){
}  
let a = String::from("Name"); 
test(&a);  
//&a就可以在不移交所有权的情况下访问该内存   
```

# '*' 解引用
作用：可以解除一层引用，直接拿到指向的数据，且可多重解引用。  
```Rust
let mut x:Box<i32> = Box::new(1);  
let a: i32 =*x;  
```
多重解引用  
```Rust
let a = Box:new(1);  
let b = &a;  
let r :i32 = **b; or let r :Box<i32> = *b;  
//*x += 1; 现在 a = 1 且类型为i32 而x为 box 2  
```
Rust 内置函数存在隐式解引用 例如 i32的.abs() string的.len()  

## 指针安全原则：数据决不能同时使用别名和变异。
原因：当一个变量a引用了变量b的数据 当变量b更改数据时，由于原数据没用所有者所以被释放，因此变量a就引用了一个无效内存.  

## 易错点
& mut变量时 需要使用可变引用才行 &mut a  
所有变量都可以 W, O, R 其数据  
创建引用会将权限从借用路径转移到引用  
引用生命周期结束，就会归还权限。  
数据必须比所有指向它的引用的生命周期更长。  

总结:引用好比借给他人东西，当东西借出去的时候，你只有那个东西的信息,由于不在手上因此无法更改。  
该过程Rust会在预编译时检验,Rust是AOT(预编译模式)。  
Rust在预编译期间对所有变量的生命周期进行了标记，当一个变量不再使用时就代表它的生命周期结束，自动释放。  
String类型在上下文中必须只存在一个所有者，因为String是堆数据，当存在复数以上的所有者时。Rust最终会释放数次导致错误。  